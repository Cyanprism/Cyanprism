#ifndef _CYANPRISM_GENERATOR
#define _CYANPRISM_GENERATOR



#include "_define"

#include <iostream>
#include <numeric>
#include <type_traits>

namespace _CYANPRISM_NAMESPACE {


template <typename Type>
class forward_generator_implementation {
public:
    virtual Type get() = 0;
    virtual void next() = 0;
    virtual bool empty() = 0;
    virtual forward_generator_implementation* copy() = 0;
    virtual ~forward_generator_implementation() = default;
};

template <typename Type>
class forward_generator {
public:
    forward_generator(forward_generator_implementation<Type>* const generator_) : _generator(generator_) {}

    forward_generator(const forward_generator<Type>& other_) : _generator(other_._generator->copy()) {}

    forward_generator(forward_generator<Type>&& other_) : _generator(other_._generator) {
        other_._generator = nullptr;
    }

    forward_generator<Type>& operator=(const forward_generator<Type>& other_) {
        delete _generator;
        _generator = other_._generator->copy();
        return *this;
    }

    forward_generator<Type>& operator=(forward_generator<Type>&& other_) {
        delete _generator;
        _generator = other_._generator;
        other_._generator = nullptr;
        return *this;
    }

    ~forward_generator() {
        delete _generator;
    }

    inline Type operator*() {
        return _generator->get();
    }

    inline void operator++() {
        _generator->next();
    }

    inline bool empty() {
        return _generator->empty();
    }

    operator bool() {
        return !empty();
    }

    forward_generator<Type>& operator+=(forward_generator<Type>& other_) {
        _generator = new merging_generator(_generator, other_._generator->copy());
        return *this;
    }

protected:
    forward_generator_implementation<Type>* _generator;

private:
    class merging_generator : public forward_generator_implementation<Type> {
    public:
        merging_generator(forward_generator_implementation<Type>* first_generator_,
                forward_generator_implementation<Type>* second_generator_) :
                _first_generator(first_generator_), _second_generator(second_generator_) {}

        merging_generator(const merging_generator&) = default;

        merging_generator(merging_generator&&) = default;

        ~merging_generator() {
            delete _first_generator;
            delete _second_generator;
        }

        merging_generator& operator=(const merging_generator&) = default;

        merging_generator& operator=(merging_generator&&) = default;

        Type get() {
            if (!_first_generator->empty()) {
                return _first_generator->get();
            } else {
                return _second_generator->get();
            }
        }

        void next() {
            if (!_first_generator->empty()) {
                _first_generator->next();
            } else {
                _second_generator->next();
            }
        }

        bool empty() {
            return _first_generator->empty() && _second_generator->empty();
        }

        merging_generator* copy() {
            return new merging_generator(_first_generator->copy(), _second_generator->copy());
        }

    private:
        forward_generator_implementation<Type>* _first_generator;
        forward_generator_implementation<Type>* _second_generator;
    };
};


template <typename Type>
class random_access_generator_implementation : public forward_generator_implementation<Type> {
public:
    virtual Type get(const size_t index_) = 0;
    virtual size_t size() = 0;
    virtual random_access_generator_implementation* copy() = 0;
    virtual ~random_access_generator_implementation() = default;

    Type get() {
        return get(_current);
    }

    void next() {
        ++_current;
    }

    bool empty() {
        return _current == size();
    }

private:
    size_t _current = 0;
};

template <typename Type>
class random_access_generator : public forward_generator<Type> {
public:
    random_access_generator() = delete;

    random_access_generator(random_access_generator_implementation<Type>* generator_) :
            forward_generator<Type>(generator_) {}

    random_access_generator(Type (*function_)(size_t), const size_t size_ = std::numeric_limits<size_t>::max()) :
            forward_generator<Type>(new functional_generator(function_, size_)) {}

    random_access_generator(const random_access_generator<Type>&) = default;

    random_access_generator(random_access_generator<Type>&&) = default;

    random_access_generator<Type>& operator=(const random_access_generator<Type>&) = default;

    random_access_generator<Type>& operator=(random_access_generator<Type>&&) = default;

    ~random_access_generator() = default;

    Type operator[](const size_t index_) {
        return dynamic_cast<random_access_generator_implementation<Type>*>
        (forward_generator<Type>::_generator)->get(index_);
    }

    size_t size() {
        return dynamic_cast<random_access_generator_implementation<Type>*>
        (forward_generator<Type>::_generator)->size();
    }

    Type operator*() = delete;
    void operator++() = delete;
    operator bool() = delete;

private:
    class functional_generator : public random_access_generator_implementation<Type> {
    public:
        functional_generator(Type (*function_)(size_t), const size_t size_) :
                _function(function_), _size(size_) {}

        functional_generator(const functional_generator&) = default;

        functional_generator(functional_generator&&) = default;

        ~functional_generator() = default;

        functional_generator& operator=(const functional_generator&) = default;

        functional_generator& operator=(functional_generator&&) = default;

        Type get(const size_t index_) {
            return (*_function)(index_);
        }

        size_t size() {
            return _size;
        }

        functional_generator* copy() {
            return new functional_generator(*this);
        }

    private:
        Type (*_function)(size_t);
        size_t _size;
    };
};


template <typename Type>
void print_generator(std::ostream& out_, forward_generator<Type> generator_,
        const char begin_[] = "(", const char end_[] = ")", const char separator_[] = ", ")
{
    out_ << begin_;
    if (generator_) {
        out_ << *generator_;
        ++generator_;
    }
    while (generator_) {
        out_ << separator_ << *generator_;
        ++generator_;
    }
    out_ << end_;
}

template <typename Type>
std::ostream& operator<<(std::ostream& out_, forward_generator<Type> generator_) {
    print_generator(out_, generator_);
    return out_;
}


}

#endif /* _CYANPRISM_GENERATOR */
