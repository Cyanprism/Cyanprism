#ifndef _CYANPRISM_BASE
#define _CYANPRISM_BASE



#include "_define"

#include <cstddef>

#include <iostream>
#include <type_traits>

namespace _CYANPRISM_NAMESPACE {


template <typename Type>
class base_array {
public:
    virtual size_t size() const = 0;
    virtual Type& operator[](size_t index_) = 0;

    virtual inline bool empty() const {
        return size() == 0;
    }
};

template <typename Type>
struct is_base_array {
private:
    template <typename TypeOfElements>
    static auto _test(base_array<TypeOfElements>*) -> std::integral_constant<bool,
            std::is_base_of<base_array<TypeOfElements>, Type>::value>;

    static std::false_type _test(void*);
public:
    static const bool value = decltype(_test(std::declval<Type*>()))::value;
};

template <typename Type>
const bool is_base_array_v = is_base_array<Type>::value;

template <typename Type>
struct enable_if_base_array : std::enable_if<is_base_array_v<Type>> {};

template <typename Type>
using enable_if_base_array_t = typename enable_if_base_array<Type>::type;

template <typename Array, typename = enable_if_base_array_t<Array>>
std::ostream& operator<<(std::ostream& out_, const Array& array_) {
    out_ << '[';
    if (!array_.empty()) {
        out_ << array_[0];
    }
    for (size_t index = 1; index < array_.size(); ++index) {
        out_ << ", " << array_[index];
    }
    out_ << ']';
    return out_;
}

template <typename Array, typename Scalar, typename = enable_if_base_array_t<Array>>
Array& operator*=(Array& array_, const Scalar& scalar_) {
    for (size_t index = 0; index < array_.size(); ++index) {
        array_[index] *= scalar_;
    }
    return array_;
}

template <typename Array, typename Scalar, typename = enable_if_base_array_t<Array>>
Array operator*(const Array& array_, const Scalar& scalar_) {
    Array new_array = array_;
    new_array *= scalar_;
    return new_array;
}


}



#endif /* _CYANPRISM_BASE */
