#ifndef _CYANPRISM_ARRAY
#define _CYANPRISM_ARRAY



#include "_define"
#include "algorithm"
#include "generator"

#include <cstddef>
#include <iostream>
#include <iterator>
#include <stdexcept>
#include <type_traits>

namespace _CYANPRISM_NAMESPACE {


template <typename Type>
class dynamic_array;

template <typename Type, std::size_t Size>
class static_array;

/*
    const cp::dynamic_array<int> can't change its size but can change its elements. If you want to forbid to change
    elements you should use cp::dynamic_array<const int> or const cp::dynamic_array<const int>.
*/

namespace _CYANPRISM_DETAILS_NAMESPACE {
    template<typename Type, std::size_t Size>
    struct _array {
        using type = static_array<Type, Size>;
    };

    template<typename Type>
    struct _array<Type, 0> {
        using type = dynamic_array<Type>;
    };
}

template <typename Type, std::size_t Size = 0>
using array = typename _CYANPRISM_DETAILS_NAMESPACE::_array<Type, Size>::type;


template <typename Type>
class dynamic_array : public random_access_generator<Type&> {
public:
    class entire_generator;
    class generator;

    dynamic_array() : _size(0), _scale(0), _array(nullptr),
                      random_access_generator<Type&>(new entire_generator(this)) {}

    explicit dynamic_array(size_t size_, const Type& default_ = Type()) :
            _size(size_), _scale(size_), _array(new Type[size_]()),
            random_access_generator<Type&>(new entire_generator(this))
    {
        for (size_t index = 0; index < size_; ++index) {
            _array[index] = default_;
        }
    }

    dynamic_array(const dynamic_array<Type>& other_) :
            _size(other_._size), _scale(other_._scale), _array(new Type[_scale]()),
            random_access_generator<Type&>(new entire_generator(this))
    {
        for (size_t index = 0; index < _size; ++index) {
            const_cast<std::remove_const_t<Type>*>(_array)[index] = other_._array[index];
        }
    }

    dynamic_array(dynamic_array<Type>&& other_) :
            _size(other_._size), _scale(other_._scale), _array(other_._array),
            random_access_generator<Type&>(new entire_generator(this))
    {
        other_._size = other_._scale = 0;
        other_._array = nullptr;
    }

    template <typename GeneratorType>
    dynamic_array(forward_generator<GeneratorType> generator_) :
            _size(0), _scale(0), _array(nullptr), random_access_generator<Type&>(new entire_generator(this))
    {
        auto proxy = const_cast<dynamic_array<Type>*>(this);
        while (generator_) {
            proxy->push_back(*generator_);
            ++generator_;
        }
    }

    ~dynamic_array() {
        delete[] _array;
    }

    dynamic_array<Type>& operator=(const dynamic_array& other_) {
        delete[] _array;
        _size = _scale = other_._size;
        _array = new Type[_scale];
        for (size_t index = 0; index < _size; ++index) {
            _array[index] = other_._array[index];
        }
        return *this;
    }

    dynamic_array<Type>& operator=(dynamic_array&& other_) {
        delete[] _array;
        _size = other_._size;
        _scale = other_._scale;
        _array = other_._array;
        other_._size = other_._scale = 0;
        other_._array = nullptr;
        return *this;
    }

    inline size_t size() const {
        return _size;
    }

    inline size_t scale() const {
        return _scale;
    }

    void rescale(const size_t new_scale_) {
        if (new_scale_ == _scale) { return; }
        _size = cp::min(_size, new_scale_);
        auto new_array = new Type[new_scale_]();
        for (size_t index = 0; index < _size; ++index) {
            const_cast<std::remove_const_t<Type>*>(new_array)[index] = std::move(_array[index]);
        }
        delete[] _array;
        _array = new_array;
        _scale = new_scale_;
    }

    void resize(const size_t new_size_) {
        if (new_size_ > _scale) {
            rescale(max(new_size_, static_cast<size_t>(_scale * _scale_coefficient)));
            _size = new_size_;
        } else if (new_size_ <= static_cast<size_t>(_scale / _scale_coefficient_2)) {
            _size = new_size_;
            rescale(min(new_size_, static_cast<size_t>(_scale / _scale_coefficient)));
        } else {
            _size = new_size_;
        }
    }

    Type& operator[](const size_t index_) const {
        if (index_ >= _size) {
            throw std::out_of_range("Out of range in cp::dynamic_array::operator[]");
        }
        return _array[index_];
    }

    Type& operator[](const size_t index_) {
        if (index_ >= _size) {
            resize(index_ + 1);
        }
        return _array[index_];
    }

    void clear() {
        delete[] _array;
        _size = 0;
        _scale = 0;
    }

    Type& push_back() {
        return operator[](size());
    }

    template <typename Type_>
    Type& push_back(Type_&& value_) {
        return const_cast<std::remove_const_t<Type>&>(operator[](size())) = std::forward<Type_>(value_);
    }

    void pop_back() {
        resize(size() - 1);
    }

private:
    size_t _size;
    size_t _scale;
    Type* _array;

    static constexpr float _scale_coefficient = 1.25;
    static constexpr float _scale_coefficient_2 = _scale_coefficient * _scale_coefficient;
};

template <typename Type>
class dynamic_array<Type>::entire_generator : public random_access_generator_implementation<Type&> {
public:
    entire_generator() = delete;

    entire_generator(dynamic_array<Type>* const array_) : _array(array_) {}

    ~entire_generator() = default;

    generator* copy() {
        return new generator(_array, 0, size());
    }

    Type& get(const size_t index_) {
        return _array->operator[](index_);
    }

    size_t size() {
        return _array->size();
    }

    Type& get() {
        throw std::logic_error("You can't call cp::dynamic_array::entire_generator::get(). \
Try to copy generator instead of using reference.");
    }

    void next() {
        throw std::logic_error("You can't call cp::dynamic_array::entire_generator::next(). \
Try to copy generator instead of using reference.");
    }

    bool empty() {
        throw std::logic_error("You can't call cp::dynamic_array::entire_generator::empty(). \
Try to copy generator instead of using reference.");
    }

private:
    dynamic_array<Type>* _array;
};

template <typename Type>
class dynamic_array<Type>::generator : public random_access_generator_implementation<Type&> {
public:
    generator() = delete;

    generator(dynamic_array<Type>* const array_, const size_t begin_, const size_t end_) :
            _array(array_), _begin(begin_), _end(end_) {}

    ~generator() = default;

    generator* copy() {
        return new generator(*this);
    }

    Type& get(const size_t index_) {
        return _array->operator[](_begin + index_);
    }

    size_t size() {
        return _end - _begin;
    }

private:
    dynamic_array<Type>* _array;
    const size_t _begin;
    const size_t _end;
};

template <typename Type>
std::ostream& operator<<(std::ostream& out_, dynamic_array<Type> array_) {
    print_generator(out_, array_, "[", "]");
    return out_;
}


template <typename Type, size_t Size>
class static_array : public random_access_generator<Type> {
public:
    static_array() : random_access_generator<Type>(new generator(this)) {
        for (size_t index = 0; index < Size; ++index) {
            _array[index] = Type();
        }
    }

    explicit static_array(const Type& default_) : random_access_generator<Type>(new generator(this)) {
        for (size_t index = 0; index < Size; ++index) {
            _array[index] = default_;
        }
    }

    static_array(const static_array& other_) : random_access_generator<Type>(new generator(this)) {
        for (size_t index = 0; index < Size; ++index) {
            _array[index] = other_._array[index];
        }
    }

    static_array(static_array&& other_) : random_access_generator<Type>(new generator(this)) {
        for (size_t index = 0; index < Size; ++index) {
            _array[index] = std::move(other_._array[index]);
        }
    }

    ~static_array() = default;

    static_array<Type, Size>& operator=(const static_array<Type, Size>& other_) {
        for (size_t index = 0; index < Size; ++index) {
            _array[index] = other_._array[index];
        }
        return *this;
    }

    static_array<Type, Size>& operator=(static_array<Type, Size>&& other_) {
        for (size_t index = 0; index < Size; ++index) {
            _array[index] = std::move(other_._array[index]);
        }
        return *this;
    }

    class generator : public random_access_generator_implementation<Type> {
    public:
        generator() = delete;

        generator(static_array<Type, Size>* const array_) : _array(array_) {}

        ~generator() = default;

        generator* copy() const {
            return new generator(_array);
        }

        Type& get(const size_t index_) {
            return _array->operator[](index_);
        }

        size_t size() const {
            return _array->size();
        }

    private:
        static_array<Type, Size>* _array;
    };

    inline size_t size() const {
        return Size;
    }

    Type& operator[](size_t index_) {
        return _array[index_];
    }

    const Type& operator[](size_t index_) const {
        return _array[index_];
    }

private:
    Type _array[Size];
};



}



#endif /* _CYANPRISM_ARRAY */
