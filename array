#ifndef _CYANPRISM_ARRAY
#define _CYANPRISM_ARRAY



#include "_define"
#include "algorithm"
#include "base"

#include <cstddef>

namespace _CYANPRISM_NAMESPACE {


template <typename Type>
class dynamic_array : public base_array<Type> {
public:
    dynamic_array() : _size(0), _scale(0), _array(nullptr) {}

    dynamic_array(size_t size_) : _size(size_), _scale(size_), _array(new Type[size_]) {}

    dynamic_array(const dynamic_array<Type>& other_) :
            _size(other_._size), _scale(other_._scale), _array(new Type[_scale])
    {
        for (size_t index = 0; index < _size; ++index) {
            _array[index] = other_._array[index];
        }
    }

    dynamic_array(dynamic_array<Type>&& other_) : _size(other_._size), _scale(other_._scale), _array(other_._array) {
        other_._size = other_._scale = 0;
        other_._array = nullptr;
    }

    ~dynamic_array() {
        delete[] _array;
    }

    inline size_t size() const {
        return _size;
    }

    inline size_t scale() const {
        return _scale;
    }

    void rescale(size_t new_scale_) {
        if (new_scale_ == _scale) { return; }
        _size = cp::min(_size, new_scale_);
        auto new_array = new Type[new_scale_];
        for (size_t index = 0; index < _size; ++index) {
            new_array[index] = std::move(_array[index]);
        }
        delete[] _array;
        _array = new_array;
        _scale = new_scale_;
    }

    void resize(size_t new_size_) {
        if (new_size_ > _scale) {
            rescale(max(new_size_, static_cast<size_t>(_scale * _scale_coefficient)));
            _size = new_size_;
        } else if (new_size_ <= static_cast<size_t>(_scale / _scale_coefficient_2)) {
            _size = new_size_;
            rescale(min(new_size_, static_cast<size_t>(_scale / _scale_coefficient)));
        } else {
            _size = new_size_;
        }
    }

    Type& operator[](size_t index_) {
        if (index_ >= _size) {
            resize(index_ + 1);
        }
        return _array[index_];
    }

    const Type& operator[](size_t index_) const {
        if (index_ >= _size) {
            throw;
        }
        return _array[index_];
    }

private:
    size_t _size;
    size_t _scale;
    Type* _array;
    static constexpr float _scale_coefficient = 1.25;
    static constexpr float _scale_coefficient_2 = _scale_coefficient * _scale_coefficient;
};


template <typename Type, size_t Size>
class static_array : public base_array<Type> {
public:
    static_array() = default;

    ~static_array() = default;

    inline size_t size() const {
        return Size;
    }

    Type& operator[](size_t index_) {
        return _array[index_];
    }

    const Type& operator[](size_t index_) const {
        return _array[index_];
    }

private:
    Type _array[Size];
};


template <typename Type, size_t Size = 0>
class array : public static_array<Type, Size> {
public:
    template <typename... Types>
    array(Types... args) : static_array<Type, Size>(args...) {}
};

template <typename Type>
class array<Type, 0> : public dynamic_array<Type> {
public:
    template <typename... Types>
    array(Types... args) : dynamic_array<Type>(args...) {}
};



}



#endif /* _CYANPRISM_ARRAY */
